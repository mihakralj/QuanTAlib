#!csharp

#r "nuget:YahooFinanceApi;" 
using YahooFinanceApi;

#!csharp

public class TSeries : System.Collections.Generic.List<(System.DateTime t, double v)>
{
    // when asked for a (t,v) tuple, return the last (t,v) on the List
    public static implicit operator (System.DateTime t, double v)(TSeries l) => l[l.Count-1];

    // when asked for a (double), return the value part of the last tuple on the list
    public static implicit operator double(TSeries l) => l[l.Count - 1].v;

    // when asked for a (DateTime), return the DateTime part of the last tuple on the list
    public static implicit operator DateTime(TSeries l) => l[l.Count - 1].t;

    public System.Collections.Generic.List<DateTime> t {
        get {return this.Select(x => (DateTime)x.t).ToList();}}

    public System.Collections.Generic.List<double> v {
        get {return this.Select(x => (double)x.v).ToList();}}

    // adding one (t,v) tuple to the end of the list - or update the last value on the list
    // trigger the broadcast of the event to subscribers
    public void Add((System.DateTime t, double v) TValue, bool update = false) {
        if (update) this[this.Count-1] = TValue; else base.Add(TValue);
        OnEvent(update);
    }
    public void Add(double v, bool update = false) {this.Add((DateTime.Now, v),update);}

    // Broadcast handler - only to valid targets
    protected virtual void OnEvent(bool update = false) {
        if (Pub!=null && Pub.Target!=this)  Pub(this, new TSeriesEventArgs() {update=update}); 
    }

    // delegate used by event handler + event handler (Pub == publisher)
    public delegate void NewDataEventHandler (object source, TSeriesEventArgs args);
    public event NewDataEventHandler Pub;

    public void Sub(object source, TSeriesEventArgs e) { 
        //this.Add(source[source.Count - 1], e.update);
        TSeries ss = (TSeries)source;
        if (ss.Count > 0) for (int i=0; i<ss.Count; i++) this.Add(ss[i], false);
        else this.Add(ss[ss.Count-1],e.update);
    }

}  

//  EventArgs extension - carries the update field
public class TSeriesEventArgs : EventArgs {
    public bool update {get; set;} 
}

#!csharp

public class SMA_TSeries : TSeries
{
    private int _p;
    private bool _NaN;
    private TSeries _data;
    private double _sma;
    private System.Collections.Generic.List<double> _buffer = new();

    public SMA_TSeries(TSeries source, int period, bool useNaN = false)
    {
        _p = period;
        _data = source;
        _NaN = useNaN;
        source.Pub += this.Sub;
        if (source.Count > 0) for (int i=0; i<source.Count; i++) this.Add(source[i], false);
    }
    public new void Add((System.DateTime t, double v) data, bool update = false)
    {
        if (update) _buffer[_buffer.Count - 1] = data.v; else _buffer.Add(data.v);
        if (_buffer.Count > _p) _buffer.RemoveAt(0);

        _sma = 0;
        for (int i = 0; i < _buffer.Count; i++) _sma += _buffer[i];
        _sma /= _buffer.Count;

        (System.DateTime t, double v) result = (data.t, (this.Count < _p - 1 && _NaN) ? double.NaN : _sma);
        if (update) base[base.Count - 1] = result; else base.Add(result);
    }
    public void Add(bool update = false)
    { this.Add(_data[_data.Count - 1], update); }

    public void Sub(object source, TSeriesEventArgs e) { this.Add(_data[_data.Count - 1], e.update); }
}

#!csharp

TSeries t1 = new() {1,2,3,4,5};
TSeries t2 = new();
SMA_TSeries sma = new(t1,3);

sma.Pub += t2.Sub;
t1.Add(1);
t2.v

#!csharp

public class EMA_Series : TSeries
{
    private int _p;
    private bool _NaN;
    private TSeries _data;
    private double _k, _k1m;
    private double _ema, _lastema, _lastlastema;

    public EMA_Series(TSeries source, int period, bool useNaN = false)
    {
        _p = period;
        _data = source;
        _k = 2.0 / (double)(period + 1);
        _k1m = 1.0 - _k;
        _NaN = useNaN;
        _lastema = _lastlastema = double.NaN;
        source.Pub += this.Sub;
    }

    public new void Add((System.DateTime t, double v) data, bool update = false)
    {
        if (update) _lastema = _lastlastema;
        _ema = System.Double.IsNaN(_lastema) ? data.v : data.v * _k + _lastema * _k1m;
        _lastlastema = _lastema;
        _lastema = _ema;

        (System.DateTime t, double v) result = (data.t, (this.Count < _p - 1 && _NaN) ? double.NaN : _ema);
        if (update) base[base.Count - 1] = result; else base.Add(result);
    }

    public void Add(bool update = false) { this.Add(_data[_data.Count - 1], update); }
    public void Sub(object source, TSeriesEventArgs e) { this.Add(_data[_data.Count - 1], e.update); }
} 

#!csharp

// ADD - adding TSeries+TSeries together, or TSeries+double, or double+TSeries
public class ADD_Series : TSeries {
    TSeries _d1, _d2;
    double _dd;

    // constructor to add two TSeries lists - needs an event subscription for each update
    public ADD_Series(TSeries d1, TSeries d2) {
        _d1 = d1;
        _d2 = d2;
        _dd = 0;
        d1.Pub += this.Sub;
        d2.Pub += this.Sub;
    }

    // constructor to add TSeries+double - needs one event subscription
    public ADD_Series(TSeries d1, double dd) {
        _d1 = d1;
        _d2 = null;
        _dd = dd;
        d1.Pub += this.Sub;
    }

    // constructor to add double+TSeries - needs one event subscription
    public ADD_Series(double dd, TSeries d1){
        _d1 = d1;
        _d2 = null;
        _dd = dd;
        d1.Pub += this.Sub;
    }

    // sum two tuples together and add to the list. use the latest timestamp if different
    public void Add((System.DateTime t, double v) d1, (System.DateTime t, double v) d2, bool update = false){
        (System.DateTime t, double v) result = ((d1.t>d2.t)?d1.t:d2.t, d1.v+d2.v);
        if (update) base[base.Count-1] = result; else base.Add(result);
    }

    // sum (t,v) tuple and (double) value - and add to the list
    public void Add((System.DateTime t, double v) d1, double dd, bool update = false){
        (System.DateTime t, double v) result = (d1.t, d1.v+dd);
        if (update) base[base.Count-1] = result; else base.Add(result);
    }

    // add through event subscription; need to check if we handle list_list or list+double
    public void Add(bool update = false) { 
        if (_d2==null) 
            this.Add(this._d1[_d1.Count-1], this._dd, update);
        else if (_d1.Count>0 && _d2.Count>0 && _d1[_d1.Count-1].t == _d2[_d2.Count-1].t) 
            this.Add(this._d1[_d1.Count-1], this._d2[_d2.Count-1], update); 
    }

    // subscribtion handler, used to attach sub to pub
    public void Sub(object source, TSeriesEventArgs e) { this.Add(e.update); }
}

#!csharp

// SUB - subtracting TSeries-TSeries, or TSeries-double, or double-TSeries
public class SUB_Series : TSeries {
    TSeries _d1, _d2;
    double _dd;
    byte _type;

    // constructor to subtract two TSeries lists - needs an event subscription for each update
    public SUB_Series(TSeries d1, TSeries d2) {
        _d1 = d1;
        _d2 = d2;
        _dd = 0;
        _type = 1;
        d1.Pub += this.Sub;
        d2.Pub += this.Sub;
    }

    // constructor to subtract TSeries-double - needs one event subscription
    public SUB_Series(TSeries d1, double dd) {
        _d1 = d1;
        _d2 = null;
        _dd = dd;
        _type = 2;
        d1.Pub += this.Sub;
    }

    // constructor to subtract double-TSeries - needs one event subscription
    public SUB_Series(double dd, TSeries d1){
        _d1 = d1;
        _d2 = null;
        _dd = dd;
        _type = 3;
        d1.Pub += this.Sub;
    }

    // subtract two tuples and add result to the list. use the latest timestamp if different
    public void Add((System.DateTime t, double v) d1, (System.DateTime t, double v) d2, bool update = false){
        (System.DateTime t, double v) result = ((d1.t>d2.t)?d1.t:d2.t, d1.v-d2.v);
        if (update) base[base.Count-1] = result; else base.Add(result);
    }

    // subtract (t,v) tuple and (double) value - and add to the list
    public void Add((System.DateTime t, double v) d1, double dd, bool update = false){
        (System.DateTime t, double v) result = (d1.t, d1.v-dd);
        if (update) base[base.Count-1] = result; else base.Add(result);
    }

    public void Add(double dd, (System.DateTime t, double v) d1, bool update = false){
        (System.DateTime t, double v) result = (d1.t, dd-d1.v);
        if (update) base[base.Count-1] = result; else base.Add(result);
    }

    // add through event subscription; need to check if we handle list_list or list+double
    public void Add(bool update = false) { 
        if (_type==1 && _d1.Count>0 && _d2.Count>0 && _d1[_d1.Count-1].t == _d2[_d2.Count-1].t) 
            this.Add(this._d1[_d1.Count-1], this._d2[_d2.Count-1], update);
        else if (_type==2) 
            this.Add(this._d1[_d1.Count-1], this._dd, update);
        else if (_type==3) 
            this.Add(this._dd, this._d1[_d1.Count-1], update);
    }

    // subscribtion handler, used to attach sub to pub
    public void Sub(object source, TSeriesEventArgs e) { this.Add(e.update); }
}

#!csharp

TSeries data = new();
SMA_Series fast = new(data, 12, true);
SMA_Series slow = new(data, 26, true);
SUB_Series macd = new(fast, slow);
SMA_Series signal = new(macd, 9, true);

var history = await Yahoo.GetHistoricalAsync("TQQQ", DateTime.Today.AddDays(-250), DateTime.Now, Period.Daily);
foreach (var i in history) {
    data.Add((i.DateTime,  (double)i.Close), update: false);
    
//Console.WriteLine($"{(double)data:f2}\t [macd]: {(double)macd:f2}\t [signal]: {(double)signal:f2}\t [up/dn]: {(double)delta:f2}");
}

#!csharp

#r "nuget: Plotly.NET, 2.0.0-preview.18 "
#r "nuget: Plotly.NET.Interactive, 2.0.0-preview.18 "
using Plotly.NET;
using Plotly.NET.LayoutObjects;

#!csharp

//GenericChart.GenericChart ch1 = Chart2D.Chart.Line<double,double,bool>(data.Select(x => (double)x.t),data.Select(x => (double)x.v),false,"data").WithLineStyle(Width: 1.0, Color: Color.fromString("blue"));
GenericChart.GenericChart ch2 = Chart2D.Chart.Line<DateTime,double,bool>(macd.Select(x => x.t), macd.Select(x => (double)x.v),false,"macd").WithLineStyle(Width: 2, Color: Color.fromString("red"));
GenericChart.GenericChart ch3 = Chart2D.Chart.Line<DateTime,double,bool>(signal.Select(x => x.t), signal.Select(x => (double)x.v),false,"signal").WithLineStyle(Width: 1.5, Color: Color.fromString("green"));
var chart = Chart.Combine(new []{ch2,ch3}).WithSize(1200,400).WithMargin(Margin.init<int, int, int, int, int, bool>(1,1,60,1,1,true)).WithTitle("MACD");
chart
